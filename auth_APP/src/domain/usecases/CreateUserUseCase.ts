import { User } from '../../types/user';
import { DomainError } from '../errors/DomainError';
import { IUserRepository } from '../repositories/IUserRepository';
import { IPasswordHasher } from '../services';
import { Email, Password, Username } from '../value-objects';

interface CreateUserInput {
  username: string;
  email: string;
  password: string;
}

/**
 * Use case for creating a new user (admin operation)
 * Does not assign any roles - roles must be assigned separately
 */
export class CreateUserUseCase {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly passwordHasher: IPasswordHasher
  ) {}

  async execute(input: CreateUserInput): Promise<User> {
    // Validate input with Value Objects
    const username = Username.create(input.username);
    const email = Email.create(input.email);
    const password = Password.create(input.password);

    // Check if username already exists
    const existingUsername = await this.userRepository.findByUsername(username.getValue());
    if (existingUsername) {
      throw new DomainError('Username already exists', 'DUPLICATE_USERNAME');
    }

    // Check if email already exists
    const existingEmail = await this.userRepository.findByEmail(email.getValue());
    if (existingEmail) {
      throw new DomainError('Email already exists', 'DUPLICATE_EMAIL');
    }

    // Hash password
    const passwordHash = await this.passwordHasher.hash(password.getValue());

    // Create user entity (id will be auto-generated by database)
    const newUser: User = {
      id: '', // Will be set by database SERIAL
      username: username.getValue(),
      email: email.getValue(),
      passwordHash,
      createdAt: new Date().toISOString()
    };

    // Save user
    const createdUser = await this.userRepository.create(newUser);

    // Return user without password hash
    return {
      ...createdUser,
      passwordHash: undefined as any
    };
  }
}
